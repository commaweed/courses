Examples of things that are different in Groovy (versus Java)general noteseverything in Groovy is an object, including operators (and their are no primitives)with asserts == represents equality (e.g. this.equals(that)), not identity (i.e ref == ref in java)with immutable objects, == is overloaded to represent equality, not identityGroovy uses dynamic method dispatch (Groovy types are not dynamic, they never change)Method calls are funneled through an object called MetaClass getMetaClass().invokeMethod(this, “foo”, EMPTY_PARAMS_ARRAY)DefaultTypeTransformation.castToType (lookup this for list of all groovy casting logic)rule of thumb: As soon as you think about the type of a reference, declare it; if you’re thinking of it as “just an object,” leave the type out.you can override some operatorsNumbersnumeric literals in Groovyjava.lang.Integer 15, 0x1234ffffjava.lang.Long 100L, 200l ← lower-case LinkedHashMapjava.lang.Float 1.23F, 1.23Fjava.lang.Double 1.23D, 1.23djava.math.BigInteger 123g, 456Gjava.math.BigDecimal 1.23, 1.4E4, 1.23g, 4.56Gfor operations +, -, and multiplication:If either operand is a Float / Double, result is a DoubleOtherwise, if either operand is a BigDecimal, result is a BigDecimalOtherwise, if either operand is a BigInteger, the result is a BigIntegerOtherwise, if either operand is a Long, the result is a LongOtherwise, the result is an Integerfor divisionif either operand is a Float / Double, result is a Doubleotherwise, the result is a BigDecimal with max precision of both args, rounded half-up (normalized - no trailing zeros)Integer division is achievable through explicit casting or by using intdiv()shifting operators are bit-shifts only for Integer and Long (you implement them for other types through op overloading)the power operator coerces to the next best type that can handle the result in terms of range (Integer, Long, then Double)the equals operator coerces to the more general type before comparingExpression ResultTypeComments1/2BigDecimal (0.5)In Java, the result would be the integer 0(int)(1/2)Integer (0)This is normal coercion of BigDecimal to Integer.1.intdiv(2)Integer (0)This is the equivalent of the Java 1/2.Integer.MAX_VALUE+1IntegerNon-power operators wrap without promoting the result type.2**30Integer2**31BigIntegerThe power operator promotes where necessary.2**3.5Double2G+1GBigInteger2.5G+1GBigDecimal1.5G==1.5FBoolean (true)Float is promoted to BigDecimal before comparison.1.1G==1.1FBoolean (false)1.1 can’t be exactly represented as a Float or Double, so when it’s promoted to BigDecimal, it isn’t equal to the exact BigDecimal 1.1G but rather 1.100000023841858G.assert 1 == (-1).abs()assert 2 == 2.5.toInteger() // conversionassert 2 == 2.5 as Integer // enforced coercionassert 2 == (int) 2.5 // castassert 3 == 2.5f.round()assert 3.142 == Math.PI.round(3)assert 4 == 4.5f.trunc()assert 2.718 == Math.E.trunc(3)assert '2.718'.isNumber() // String methodsassert 5 == '5'.toInteger()assert 5 == '5' as Integerassert 53 == (int) '5' // (asci 53 = '5')assert '6 times' == 6 + ' times' // Number + Stringsome GDK methods on numbersdef store = ''10.times{ store += 'x' }assert store == 'xxxxxxxxxx'store = ''1.upto(5) { number -> store += number }assert store == '12345'store = ''2.downto(-2) { number -> store += number + ' ' }assert store == '2 1 0 -1 -2 'store = ''0.step(0.5, 0.1){ number -> store += number + ' ' }assert store == '0 0.1 0.2 0.3 0.4 'Decimals can use exponents, with the e or E exponent letterassert 1e3 == 1_000.0 // 1e3 == 1 x 10^3 (scientific notation)assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04 assert 5e-1 == 0.5 // 5e-1 == 5 x 10^-1Arithmetic operators also work with BigInteger and BigDecimaldef one = new BigInteger('456')def two = new BigDecimal('123.45') assert (one + two) == 579.45d //the d denotes a BigDecimal literal, but its optionalassert (one + two) instanceof java.math.BigDecimalDivision// division produces double if operand float or double, and BigDecimal otherwiseassert (1.0f / 0.2f) instanceof java.lang.Doubleassert (5L / 2i) instanceof java.math.BigDecimal// so how do we get integral type from integral division (java truncates)assert (5L).intdiv(2i) instanceof java.lang.LongThe power operator (in java Math.pow(x,y))assert 2 ** 3 instanceof Integer // 2^3 = 8assert 10 ** 9 == 1_000_000_000// the result can't be represented as an Integer or Long, so return a BigIntegerassert 100 ** 10 instanceof BigInteger assert 100 ** 10 == 1e20 // 1 x 10^10some groovy examples of how numbers are treated as objects(60 * 60 * 24 * 365).toString(); // invalid Javaint secondsPerYear = 60 * 60 * 24 * 365; secondsPerYear.toString(); // invalid Javanew Integer(secondsPerYear).toString();assert "abc" - "a" == "bc" // invalid Javaassert 'ABCDE'.indexOf(67) == 2assigning types to numbers doesn’t imply they will have that typeint c = 1 // explicit type becomes java.lang.Integer (because Groovy doesn't use primitives)float d = 1 // java.lang.Floatcoercion of numbers (promoting to more general type)1 + 1.0 // add Integer to BigDecimal - need to promote Integer (more specific type) to BigDecimal (more general type)BooleanGroovy TruthRuntime typeEvaluation criterion required for truthBooleanCorresponding Boolean value is trueMatcherMatcher has a matchCollection Collectionis nonemptyMap Mapis nonemptyString, GStringString is nonemptyNumber, CharacterValue is nonzeroNone of the aboveObject reference is non-null//Groovy has special rules for coercing non-boolean objects to a boolean value // True if the Matcher has at least one match.assert ('a' =~ /a/)assert !('a' =~ /b/)// Iterators and Enumerations with further elements are coerced to true.assert [0].iterator()assert ![].iterator()// Non-empty Maps are evaluated to true.assert ['one' : 1]assert ![:]// Non-empty Strings, GStrings and CharSequences are coerced to true.assert 'a'assert !''def nonEmpty = 'a'assert "$nonEmpty"def empty = ''assert !"$empty"// Non-zero numbers are true.assert 1assert 3.5assert !0// Non-null object references are coerced to true.assert new Object()assert !null// Customizing the truth with asBoolean() methods// In order to customize whether groovy evaluates your object to true or false implement asBoolean()class Color { String name boolean asBoolean(){ name == 'green' ? true : false }}assert new Color(name: 'green')assert !new Color(name: 'red')watch out for groovy truth coding errors
```java
// normal comparison
def x = 1
if (x == 2) {
 assert false
}// compile error - top level if doesn’t allow assignment
/*
if (x = 2) {
println x
}
**/// 1. ouch! nested expression is ok; assignment occurs and then groovy thruth evaluation occurs
if ((x = 3)) { println x }
assert x == 3// deliberate assign and test in a while statement is ok (it will loop until x is 0)
def store = []
while (x = x - 1) { store << x }
assert store == [2, 1]// 2. ouch! this will print 2
while (x = 2) {
 println x
 break
}* groovy supports a shortcut for ? : ```javadef argument = "given"def standard = "default"def result = argument ? argument : standarddef value = argument ?: standard // you can rewrite the above using short notationassert result == "given"assert value == "given"assert result == valueA classifier is eligible as a switch case if it implements the isCase methodUnlike Java’s constant cases, the candidate may match more than one classifier; implies order of cases is important.standard implementations of isCase for switch, grep, and inClassa.isCase(b) implemented asObjecta.equals(b)Classa.isInstance(b)Collectiona.contains(b)Rangea.contains(b)Patterna.matcher(b.toString()).matches()String(a==null && b==null) or a.equals(b)Closurea.call(b)The isCase method is also used with grep on collections such that collection.grep(classifier) returns a collection of all items that are a case of that classifier.switch (10) { case 0 : assert false ; break case 0..9 : assert false ; break case [8,9,11] : assert false ; break case Float : assert false ; break // we classify by type (GDK enhances Class by adding an isCase method - tests with isInstance) case {it%3 == 0}: assert false ; break case ~/../ : assert true ; break // A pattern has an isCase method; applies test to the toString of the argument default : assert false ; break}// example in operatordef okValues = [1, 2, 3]def value = 2assert value in okValues// assertions can be instrumented with a trailing messageinput = new File('no such file')assert input.exists() , "cannot find '$input.name'" //... cannot find 'no such file'. Expression: input.exists()assert input.canRead() , "cannot read '$input.canonicalPath'"println input.textloopswhile loops can use groovy truths (i.e. boolean test expressions) - the Boolean test is evaluated, and if it’s true, the body of the loop is then executed.there are no do {} while(condition) or repeat {} until (condition) loops in Groovy.for (variable in iterable) { body } // variable can have an optional typethe body of a for loop is not a closure// some while loop examplesdef list = [1,2,3]while (list) { list.remove(0) }assert list == []while (list.size() < 3) list << list.size()+1assert list == [1,2,3]// for: explicit typing over strict rangedef store = ''for (String s in 'a'..'c') store += sassert store == 'abc'// for: explicit typing over list as collectionstore = ''for (i in [1, 2, 3]) { store += i }assert store == '123'// for: explicit typing using java-style for loopdef myString = 'Old school Java'store = ''for (int i=0; i < myString.size(); i++) { store += myString[i] }assert store == myString// for: explicit typing using java-style for iterable indexmyString = 'Java range index'store = ''for (int i : 0 ..< myString.size()) { store += myString[i] }assert store == myString// for: implicit typing over half-exclusive IntRangemyString = 'Groovy range index'store = ''for (i in 0 ..< myString.size()) { store += myString[i] }assert store == myString// for: java-style for-inmyString = 'Java string Iterable'store = ''for (String s : myString) { store += s }assert store == myString// for: groovy-style for-inmyString = 'Groovy iterator'store = ''for (s in myString) { store += s }assert store == myString// If the container object is null, no iteration will occurfor (x in null) println 'This will not be printed!' // If Groovy cannot make the container object iterable by any means, the fallback solution is to do an iteration that contains only the container object itselffor (x in new Object()) println "Printed once for object $x" // for loop body is not a closurefor (x in 0..9) { println x }// but the body of each is a closure(0..9).each { println it }StringsQuoted identifiers (and string types)def map = [:]map.'single quote' //java.lang.String (no interpolation support)map."double quote" //interpolated java.lang.String if no interpolation, groovy.lang.GString otherwise map.'''triple single quote''' //multiline java.lang.String (no interpolation support)map."""triple double quote""" //multiline/interpolated java.lang.String no interpolation, groovy.lang.GString otherwise map./slashy string/ //multiline/interpolated good for regular expressions (no need to escape the \, but / does)map.$/dollar slashy string/$ //multiline/iterpolated ($ is the escape (\ is escape for the others))/* note: multiline strings preserves whitespace if indenting. But, The Groovy Development Kit contains methods for stripping out the indentation with the String#stripIndent() method, and with the String#stripMargin() method that takes a delimiter character to identify the text to remove from the beginning of a string. Also can use \ to exclude carriage return as first character*/// Neither double quotes nor single quotes need be escaped in triple double quoted strings.GString interpolation (resolving values)/* Any Groovy expression can be interpolated in all string literals (sep ' types). Not only expressions are actually allowed in between the ${} placeholder. Statements are also allowed,but a statement’s value is just null. So if several statements are inserted in that placeholder,the last one should somehow return a meaningful value to be inserted. Example "The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}"In addition to ${} placeholders, we can also use a lone $ sign prefixing a dotted expression (a.b.c)*/def firstname = "Homer"def map = [:]map."Simson-${firstname}" = "Homer Simson"assert map.'Simson-Homer' == "Homer Simson"println "hello $firstname or ${firstname.toString()}"GString interpolation using closures - lazy evaluation//When the placeholder contains an arrow, ${→}, the expression is actually a closure expression.// 1. parameterless closure which doesn’t take argumentsdef sParameterLessClosure = "1 + 2 == ${-> 3}" assert sParameterLessClosure == '1 + 2 == 3' // 2. closure takes a single java.io.StringWriter argument, to which you can append content with the <<def sOneParamClosure = "1 + 2 == ${ w -> w << 3}" assert sOneParamClosure == '1 + 2 == 3'/* In appearance, it looks like a more verbose way of defining expressions to be interpolated, but closures have an interesting advantage over mere expressions: lazy evaluation. */def number = 1 def eagerGString = "value == ${number}"def lazyGString = "value == ${ -> number }"assert eagerGString == "value == 1" assert lazyGString == "value == 1" number = 2 assert eagerGString == "value == 1" assert lazyGString == "value == 2" //closure uses new value/* An embedded closure expression taking more than one parameter will generate an exception at runtime. Only closures with zero or one parameters are allowed. */GString versus String (they are not the same, although they could appear to be the same)// String is immutable and will have same hashcode when copared to self, GString is noteprintln "one: ${1}"; println "one: 1"assert "one: ${1}".hashCode() != "one: 1".hashCode()output:one: 1one: 1// using GString as Map keys should be avoideddef key = "a"def m = ["${key}": "letter ${key}"] assert m["a"] == nullGString placeholder evaluationEach placeholder inside a GString is evaluated at declaration time; result is stored in a GString objectBy the time the GString value is converted to a java.lang.String (toString() or casting), each value gets written to the string.Unlike Java, Groovy doesn’t have an explicit character literal; ways to convert it to character// 1. create java static typechar c1 = 'A' assert c1 instanceof Character// 2. use 'as' keyword (type coercion)def c2 = 'B' as char assert c2 instanceof Character// 3. use static type castdef c3 = (char) 'C' assert c3 instanceof Character// 4. use method'A'.toCharacter()some miscellaneous string examplesString greeting = 'Hello Groovy!'assert greeting.startsWith('Hello')assert greeting.getAt(0) == 'H'assert greeting[0] == 'H'assert greeting.indexOf('Groovy') >= 0assert greeting.contains('Groovy')assert greeting[6..11] == 'Groovy'assert 'Hi' + greeting - 'Hello' == 'Hi Groovy!'assert greeting.count('o') == 3assert 'x'.padLeft(3) == ' x'assert 'x'.padRight(3,'_') == 'x__'assert 'x'.center(3) == ' x 'assert 'x' * 3 == 'xxx'def greeting = 'Hello'greeting <<= ' Groovy' // #1 Leftshift and assignassert greeting instanceof java.lang.StringBuffergreeting << '!' //#2 Leftshift on StringBufferassert greeting.toString() == 'Hello Groovy!'greeting[1..4] = 'i' //#3 Substring 'ello' becomes 'i'assert greeting.toString() == 'Hi Groovy!'using a left shift operator on String returns a StringBuilderdef greeting = 'Hello'assert greeting instanceof java.lang.Stringgreeting <<= ' Groovy' // #1 Leftshift and assignassert greeting instanceof java.lang.StringBuffergreeting << '!' //#2 Leftshift on StringBufferassert greeting.toString() == 'Hello Groovy!'greeting[1..4] = 'i' //#3 Substring 'ello' becomes 'i'assert greeting.toString() == 'Hi Groovy!'some properties with GStringdef me = 'Tarzan'def you = 'Jane'def line = "me $me - you $you"assert line == 'me Tarzan - you Jane'assert line instanceof GStringassert line.strings[0] == 'me 'assert line.strings[1] == ' - you 'assert line.values[0] == 'Tarzan'assert line.values[1] == 'Jane' 14regular expressionsregex find operator, =~ (its a matcher, but can also be used as a Boolean conditional)regex match operator, ==~ (more restrictive because the match must cover the entire string)regex pattern operator, ~stringSometimes the slashy syntax interferes with other valid Groovy expressions such as line comments or numerical expressions with multiple slashes for divisionput parentheses around your pattern like (/pattern/)Parentheses force the parser to interpret the content as an expressiongroovy supports the following tasks for RE:Tell whether the pattern fully matches the whole string.Tell whether there’s an occurrence of the pattern in the string.Count the occurrences.Do something with each occurrence.Replace all occurrences with some text.Split the string into multiple strings by cutting at each occurrence.two different ways to iterate through matches with identical behavior: use String.eachMatch(Pattern)use Matcher.each()def twister = 'she sells sea shells at the sea shore of seychelles'// twister must contain a substring of size 3 that starts with s and ends with aassert twister =~ /s.a/def finder = (twister =~ /s.a/)assert finder instanceof java.util.regex.Matcher println finder.find() // trueprintln finder.group() // sea// twister must contain only words delimited by single spacesassert twister ==~ /(\w+ \w+)*/def WORD = /\w+/matches = (twister ==~ /($WORD $WORD)*/)assert matches instanceof java.lang.Booleanassert !(twister ==~ /s.e/)def wordsByX = twister.replaceAll(WORD, 'x')assert wordsByX == 'x x x x x x x x x x'def words = twister.split(/ /)assert words.size() == 10assert words[0] == 'she'def myFairStringy = 'The rain in Spain stays mainly in the plain!'// words that end with 'ain': \b\w*ain\bdef wordEnding = /\w*ain/def rhyme = /\b$wordEnding\b/def found = ''myFairStringy.eachMatch(rhyme) { match -> found += match + ' '}assert found == 'rain Spain plain 'found = ''(myFairStringy =~ rhyme).each { match -> found += match + ' '}assert found == 'rain Spain plain 'def cloze = myFairStringy.replaceAll(rhyme){ it-'ain'+'___' }assert cloze == 'The r___ in Sp___ stays mainly in the pl___!'def matcher = 'a b c' =~ /\S/assert matcher[0] == 'a'assert matcher[1..2] == ['b','c']assert matcher.size() == 3// Groovy parallel assignment exampledef (a,b,c) = 'a b c' =~ /\S/assert a == 'a'assert b == 'b'assert c == 'c'// what matcher[0] returns depends on whether the pattern contains groupingsdef matcher = 'a:1 b:2 c:3' =~ /(\S+):(\S+)/assert matcher.hasGroup()assert matcher[0] == ['a:1', 'a', '1'] // 1st matchassert matcher[1][2] == '2' // 2nd match, 2nd group// the matcher will match 3 times, passing full match and the two groups into each closure// match[1]=key and match[2]=valuedef matcher = 'a:1 b:2 c:3' =~ /(\S+):(\S+)/matcher.each { full, key, value ->assert full.size() == 3 // a:1, b:2, c:3assert key.size() == 1 // a, b, cassert value.size() == 1 // 1, 2, 3}rangesleft..right(left..right) - it has a low precedence so you may need to include parenthesis(left..<right) - half-exclusive range - value on the right isn’t part of the rangeYou can switch lower side with higher side for a reverse rangea range can have bounds other than integers, such as dates and stringsgroovy supports ranges at the language level with a special for-in-range loopDate objects can be used in ranges c because the GDK adds the previous and next methods to date, which increases or decreases the date by one day.The GDK also adds minus and plus operators to java.util.Date, which increases or decreases the date by so many days.The String methods previous and next are added by the GDK to make strings usable for rangesThe last character in the string is incremented or decremented, and overflow or underflow is handled by appending a new character or deleting the last character// inclusive rangesassert (0..10).contains(0)assert (0..10).contains(5)assert (0..10).contains(10)assert (0..10).contains(-1) == falseassert (0..10).contains(11) == false// half-exclusive rangesassert (0..<10).contains(9)assert (0..<10).contains(10) == false// references to rangesdef a = 0..10assert a instanceof Range // groovy.lang.Rangeassert a.contains(5)// explicit constructiona = new IntRange(0,10)assert a.contains(5)// bounds checkingassert (0.0..1.0).contains(1.0)assert (0.0..1.0).containsWithinBounds(0.5)// date rangesdef today = new Date()def yesterday = today - 1assert (yesterday..today).size() == 2// string rangesassert ('a'..'c').contains('b')// for-in-range loopdef log = ''for (element in 5..9) { log += element}assert log == '56789'// loop with reverse rangelog = ''for (element in 9..5){ log += element}assert log == '98765'// half-exclusive, reverse, each with closure (also shows iteration method each())log = ''(9..<5).each { element -> log += element}assert log == '9876'assert 5 in 0..10assert (0..10).isCase(5)// ranges for classificationdef age = 36switch(age){ case 16..20 : insuranceRate = 0.05 ; break case 21..50 : insuranceRate = 0.06 ; break case 51..65 : insuranceRate = 0.07 ; break default: throw new IllegalArgumentException()}assert insuranceRate == 0.06// filtering with rangesdef ages = [20, 36, 42, 56]def midage = 21..50assert ages.grep(midage) == [36, 42]Any data type can be used with ranges as long as:it implements next and previous; that is, it overrides the ++ and — operators.it implements java.lang.Comparable; that is, it implements compareTo, effectively overriding the <=> (spaceship) operatorclass Weekday implements Comparable { static final DAYS = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ] private int index = 0 Weekday(String day) { index = DAYS.indexOf(day) } // allow all values Weekday next() { return new Weekday(DAYS[(index + 1) % DAYS.size()]) } Weekday previous() { return new Weekday(DAYS[index - 1]) } // range bound methods int compareTo(Object other) { return this.index <=> other.index } String toString() { return DAYS[index] }}def mon = new Weekday('Mon')def fri = new Weekday('Fri')def worklog = ''for (day in mon..fri) { worklog += day.toString() + ' '}assert worklog == 'Mon Tue Wed Thu Fri 'Lists and arrays ArraysGroovy uses a comma-separated lists of values, surrounded by square brackets, for list and arrayslists make use of the subscript operator to retrieve and assign values, but they are bound to integer typesLists are by default of type java.util.ArrayListLists can be created and initialized at the same time by calling toList on rangesThe GDK extends all arrays, collection objects, and strings with a toList method that returns a newly generated list of the contained elements. Strings are handled like lists of characters.lists implement the getAt and putAt methods to support the subscript operator.there are also operators available to change the contents of the list in a more drastic way: plus(Object)plus(Collection)leftShift(Object)minus(Collection)multiplythe equals method on lists tests that two collections have equal elements (java.util.List#equals)some list methods not covered: collate, collectMany, combinations, dropWhile, flatten, groupBy, permutations, take, transpose, and withIndex.The GDK also introduces two convenience methods for producing views backed by an existing list: asImmutable and asSynchronized. These methods use Java’s Collections.unmodifiableList and Collections.synchronizedListLists// homogeneous listdef numbers = [1, 2, 3]assert numbers.size() == 3assert numbers[0] == 1assert numbers instanceof java.util.Listassert numbers instanceof ArrayList// heterogeneous listdef manyTypes = [ 1, "a", true ]assert manyTypes instanceof java.util.ArrayList// empty listList emptyList = []assert emptyList.size() == 0// long listList longList = (0..1000).toList()assert longList[555] == 555// coerce to a different type of Listdef coercionOkay = [ 1, 2, 3 ] as LinkedList// access elements using array-like [#] notationdef letters = ['a', 'b', 'c', 'd']assert letters[0] == 'a'assert letters[-1] == 'd'println letters[4] // displays null (no ArrayIndexOutOfBoundsException)//println letters[-5] //ArrayIndexOutOfBoundsException// modify list elementletters[2] = 'C'assert letters[2] == 'C'// add to the end of the listletters << 'e'assert letters[4] == "e"// return a new list def newList = letters[1, 3]assert newList == ['b', "d"]assert newList instanceof java.util.ArrayListassert letters[2..4] == ['C', 'd', 'e'] // using range to make new list// list of listsdef multi = [[0, 1], [2, 3]] assert multi[1][0] == 2 myList = ['a','b','c','d','e','f']assert myList[0..2] == ['a','b','c'] // getAt(range)assert myList[0,2,4] == ['a','c','e'] // getAt(collection of indexes)myList[0..2] = ['x','y','z'] // putAt(Range)assert myList == ['x','y','z','d','e','f'] myList[3..5] = [] // removing elementsassert myList == ['x','y','z']myList[1..1] = [0, 1, 2] // adding elementsassert myList == ['x', 0, 1, 2, 'z']// plus operatormyList = []myList += 'a' // plus(Object) assert myList == ['a'] myList += ['b','c'] // plus(Collection) assert myList == ['a','b','c']// some other operatorsmyList = []myList << 'a' << 'b' // left shift operator (like append)assert myList == ['a','b']assert myList - ['b'] == ['a'] // minus(collection)assert myList * 2 == ['a','b','a','b'] // multiply// control structures - can be used for execution of flow (if, switch, and for control structures)myList = ['a', 'b', 'c']assert myList.isCase('a')assert 'b' in myListdef candidate = 'c'switch(candidate){ case myList : assert true; break // contains default : assert false}assert ['x','a','z'].grep(myList) == ['a'] // intersection filtermyList = []if (myList) assert false // groovy truth - empty lists are false// Lists can be iterated with a 'for' loopdef expr = ''for (i in [1,'*',5]){ expr += i}assert expr == '1*5'// API list method examples//==========================assert [1,[2,3]].flatten() == [1,2,3]assert [1,2,3].intersect([4,3,1])== [3,1]assert [1,2,3].disjoint([4,5,6])// treating a list like a stacklist = [1,2,3]popped = list.pop()assert popped == 3assert list == [1,2]list.push(3)assert list == [1,2,3]assert [1,2].reverse() == [2,1]assert [3,1,2].sort() == [1,2,3]// comparing lists by first elementdef list = [ [1,0], [0,1,2] ]list = list.sort { a,b -> a[0] <=> b[0] } // sorting by first element valueassert list == [ [0,1,2], [1,0] ]// comparing lists by sizelist = list.sort { item -> item.size() } // sorting by sizeassert list == [ [1,0], [0,1,2] ]// removing by indexlist = ['a','b','c']list.remove(2)assert list == ['a','b']list.remove('b')assert list == ['a']// removing by valuelist = ['a','b','b','c']list.removeAll(['b','c'])assert list == ['a']// transform one list into another (similar to map() in java 8)def doubled = [1,2,3].collect{ item -> item * 2 }assert doubled == [2,4,6]// finding every element matching the closuredef odd = [1,2,3].findAll{ item -> item % 2 == 1 }assert odd == [1,3]// two ways to remove duplicates def x = [1, 1, 1]assert [1] == new HashSet(x).toList() // convert to set, then back to list (creates a new collection)assert [1] == x.unique() // call unique to remove duplicates (does not create a new collection)// two ways to remove null from a collectiondef x = [1,null,1]assert [1,1] == x.findAll{it != null} // use a closure to match on non-null elementsassert [1,1] == x.grep{it} // each element is subjected to groovy truth (null is false)def list = [1, 2, 3, 4, 5, 3]assert list.first() == 1assert list.head() == 1assert list.tail() == [2, 3, 4, 5, 3]assert list.last() == 3assert list.count(3) == 2assert list.max() == 5assert list.min() == 1assert 2 = list.find { item -> item % 2 == 0 } // find the first even numberassert list.every { item -> item < 5 } // is every item less than 5assert list.any { item -> item < 2 } // is any item < 2def store = ''list.each { item -> store += item }assert store == '123453'store = ''list.reverseEach { item -> store += item }assert store == '354321'def store = ''list.eachWithIndex { item, index -> store += "$index:$item " }assert store == '0:1 1:2 2:3 3:4 4:5 5:3 'assert list.join('-') == '1-2-3-4-5-3'result = list.inject(8) { clinks, guests -> clinks + guests } // similar to reduce(sum) in java assert result == 8 + 1 + 2 + 3 + 4 + 5 + 3 // 26assert list.sum() == 18factorial = list.inject(7) { fac, item -> fac * item } // similar to reduce(multiply) in java assert factorial == 7 * 1 * 2 * 3 * 4 * 5 * 3In addition to positive index values, lists can be subscripted with negative indexes that count from the end of the list backwardAvoid negative indexes with half-exclusive rangesExample List Values01234Positive Index0123456Negative Index-7-6-5-4-3-1Bounds (out or in)OOIIIIIOO// the above table uses the following codedef list = [0,1,2,3,4]def reverse = list[4..0] // creates a new listassert reverse == [4,3,2,1,0]assert list[-1] == 4 // last entry of non-empty listassert list[-2] == 3assert list[-3..-1] == [2,3,4]assert reverse[-1] == 0assert reverse[-2] == 1assert reverse[-3..-1] == [2,1,0]Arrays need to be coerced or casted as such (otherwise they’ll be lists)// define arrayString[] arrStr = ['Ananas', 'Banana', 'Kiwi'] assert arrStr instanceof String[] assert !(arrStr instanceof List)// coerce arraydef coercedArray = ['Ananas', 'Banana', 'Kiwi'] as String[]assert coercedArray instanceof String[] // create new array (example using multi-dimensional)def matrix1 = new Integer[3][3] assert matrix1.size() == 3assert matrix1[0][0] == nullInteger[][] matrix2matrix2 = [[1,2],[3,4]] //looks like list notation, but it's an arrayassert matrix2 instanceof Integer[][]// java array initializer is not supported for Groovy ({} confused as closure)// int[] matrix3 = new int[] { 1, 2, 3 } //produces compile errorMaps (also called dictionaries or associative arrays)Groovy uses a comma-separated list of values for maps, accept each value will be a key:value pair.Just like lists, maps make use of the subscript operator to retrieve and assign values but can use any arbitrary typeliterally declared maps are of type LinkedHashMap (can rely on the ordering of entries, keys, and values)Map’s each method takes a closure that takes either a Map.Entry object or key / value pair depending on whether the closure takes one or two arguments// declare an empty mapdef map = [:]assert emptyMap.size() == 0// map definition (the names become strings)def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']assert colors instanceof java.util.Mapassert colors instanceof java.util.HashMapassert colors instanceof java.util.LinkedHashMap // this is actual typeassert colors['red'] == '#FF0000'assert colors.green == '#00FF00' colors['pink'] = '#FF00FF' // one way to put a key/value paircolors.yellow = '#FFFF00' // another way to putassert colors.size() == 5// if it can determine the type, it won't make key a string typedef numbers = [ 1: 'one', 2: 'two' ]assert numbers[1] == 'one'assert numbers.keySet() instanceof Setassert numbers.keySet()[0] == 1assert numbers.keySet()[0] instanceof Integerassert numbers.containsKey(1)// do not use variable values as keys; you can get runtime errordef key = 'name'def person = [ key: 'Guillame' ] // Groovy makes key[0] = 'key', not 'name'assert !person.containsKey('name')assert person.containsKey('key')//quotes required on identifiers that are not valid (e.g. space, hyphen, etc.)person."street-name" = 'fake street'person./1xxx/ = /ksdjf/assert person[/1xxx/] == /ksdjf/// you can use variables as keys if you escape it with ()person = [(key): 'Guillaume'] assert person.containsKey('name') assert !person.containsKey('key')def myMap = [a:1, b:2, c:3]def explicitMap = new TreeMap()explicitMap.putAll(myMap)assert explicitMap['a'] == 1def composed = [x:'y', *:myMap] // use of the spread operatorassert composed == [x:'y', a:1, b:2, c:3]// strings around key that are of type String are optional (cannot contain special characters)assert ['a':1] == [a:1]// keys derived from local variablesdef x = 'a'assert ['x':1] == [x:1]assert ['a':1] == [(x):1]def myMap = [a:1, b:2, c:3]// retrieve existing elementsassert myMap['a'] == 1assert myMap.a == 1assert myMap.get('a') == 1assert myMap.get('a',0) == 1// attempting to retrieve non-existing elements (produces null)assert myMap['d'] == nullassert myMap.d == nullassert myMap.get('d') == null// default valueprintln myMap // [a:1, b:2, c:3]assert myMap.get('d',0) == 0 // inserts default value if not presentprintln myMap // [a:1, b:2, c:3, d:0]assert myMap.d == 0 // single putmyMap['d'] = 1 // d was 0, now it is 1assert myMap.d == 1myMap.d = 2 // d was 1, now it is 2assert myMap.d == 2// if key contains special characters myMap = ['a.b':1]assert myMap.'a.b' == 1def myMap = [a:1, b:2, c:3]def other = [b:2, c:3, a:1]// call to equals()assert myMap == other// JDK methodsassert !myMap.isEmpty()assert myMap.size() == 3assert myMap.containsKey('a')assert myMap.containsValue(1)assert myMap.entrySet() instanceof Collection// GDK methodsassert myMap.any { entry -> entry.value > 2 }assert myMap.every { entry -> entry.key < 'd' }assert myMap.keySet() == ['a','b','c'] as Setassert myMap.values().toList() == [1, 2, 3]// iterating over mapsdef myMap = [a:1, b:2, c:3]def store = ''myMap.each { entry -> store += entry.key store += entry.value}assert store == 'a1b2c3'store = ''myMap.each { key, value -> store += key store += value}assert store == 'a1b2c3'store = ''for (key in myMap.keySet()) { store += key }assert store == 'abc'store = ''for (value in myMap.values()) { store += value }assert store == '123'// changing map content and building new objects from itdef myMap = [a:1, b:2, c:3]myMap.clear() // jdkassert myMap.isEmpty() // jdkmyMap = [a:1, b:2, c:3]myMap.remove('a')assert myMap.size() == 2assert [a:1] + [b:2] == [a:1, b:2]myMap = [a:1, b:2, c:3]def abMap = myMap.subMap(['a', 'b'])assert abMap.size() == 2abMap = myMap.findAll { entry -> entry.value < 3 }assert abMap.size() == 2assert abMap.a == 1def found = myMap.find { entry -> entry.value < 2 } // find first value < 2assert found.key == 'a'assert found.value == 1def doubled = myMap.collect { entry -> entry.value *= 2 } // transform, like map() in java 8assert doubled instanceof Listassert doubled.every { item -> item % 2 == 0 }def addTo = []myMap.collect(addTo) { entry -> entry.value *= 2 }assert addTo instanceof Listassert addTo.every { item -> item % 2 == 0 }ClosuresGroovy provides a default name “it”, so that you don’t need to declare it specificallyWhen there’s only one parameter passed into the closure, its declaration is optional. The magic variable “it” can be used instead.whenever you see braces of a closure, thing “new groovy.lang.Closure() {}”Closures are objectsthey can be stored in variablesthey can be passed aroundyou can call methods on themyou can reference a method as a closure using the “reference.&” operator def c = reference.&someMethodYou can support closures with diffrerent parameter styles by using Closure’s getMaximumNumberOfParameters() and getParameterTypes()closure composition (f(g(x))) - pointing from the inner to the outer closureyou can use the closure memoize() function to cache results; some other methodsmemoizeAtMostmemoizeAtLeastmemoizeBetweenthere is a trampoline() that can be used with recursion to avoid stack overflowClosures implement the isCase() to make them work as classifiers in the grep and switch statements (evaluates to Groovy Boolean)// java 5 for (ItemType item : list) { /* do something with item */ }// groovy with java 5list.each { item -> /* do something with item */ }// java 8 list.stream().forEach( item -> /* do something with item */ );// groovy with java 8list.stream().forEach { println it }def log = ''(1..10).each { counter -> log += counter }assert log == '12345678910'log = ''(1..10).each { log += it }assert log == '12345678910'// declaring a closure by assigning it to a variable // e.g. def Closure getPrinter() { return { line -> println line } }def printer = { line -> println line }Class SizeFilter { Integer limit boolean sizeUpTo(String value) { return value.size() <= limit }}def words = [ 'long string', 'medium', 'short', 'tiny' ]// GroovyBean constructor callsSizeFilter filter6 = new SizeFilter(limit:6)SizeFilter filter5 = new SizeFilter(limit:5)// method closure assignmentClosure sizeUpTo6 = filter6.&sizeUpTo// calling with closureassert 'medium' == words.find(sizeUpTo6)// passing a method closure directlyassert 'short' == words.find(filter5.&sizeUpTo)class MultiMethodSample { // overloaded methods int mysteryMethod (String value) { return value.length() } int mysteryMethod (List list) { return list.size() } int mysteryMethod (int x, int y) { return x+y }}// runtime overload resolution closure exampleMultiMethodSample instance = new MultiMethodSample()Closure multi = instance.&mysteryMethodassert 10 == multi ('string arg')assert 3 == multi (['list', 'of', 'values'])assert 14 == multi (6, 8)// different ways to perform closures on the following mapMap map = ['a':1, 'b':2]// 1. simple closuremap.each{ key, value -> map[key] = value * 2 }assert map == ['a':2, 'b':4]// 2. closure assignment to a variableClosure doubler = {key, value -> map[key] = value * 2 }map.each(doubler)assert map == ['a':4, 'b':8]// 3. referencing an existing method as a closuredef doubleMethod (entry) { entry.value = entry.value * 2 }doubler = this.&doubleMethodmap.each(doubler)assert map == ['a':8, 'b':16]// another example of calling closures def adder = { x, y=5 -> return x + y } // similar to: def adder(x, y) { return x + y }assert adder(4, 3) == 7assert adder.call(2, 6) == 8assert adder.call(7) == 12 // when y is missing, use 5 by default// an example of a method that takes a closuredef benchmark(int repeat, Closure worker) { def start = System.nanoTime() repeat.times { worker(it) } def stop = System.nanoTime() return stop - start}def slow = benchmark(10000) { (int) it / 2 }def fast = benchmark(10000) { it.intdiv(2) }assert fast * 2 < slow// example of some groovy.lang.Closure methodsdef numParams (Closure closure){ closure.getMaximumNumberOfParameters() }assert numParams { one -> } == 1assert numParams { one, two -> } == 2def paramTypes (Closure closure){ closure.getParameterTypes() }assert paramTypes { String s -> } == [String]assert paramTypes { Number n, Date d -> } == [Number, Date]// curry example (not sure how I would ever use this)def mult = { x, y -> return x * y }def twoTimes = mult.curry(2) // or you could do def twoTimes = { y -> mult 2, y }assert twoTimes(5) == 10// closure composition (f(g(x))) - pointing from the inner to the outer closuredef fourTimes = twoTimes >> twoTimesdef eightTimes = twoTimes << fourTimesassert eightTimes(1) == twoTimes(fourTimes(1))// caching results that are called often with the same argumentsdef fib //fibonaccifib = { it < 2 ? 1 : fib(it-1) + fib(it-2) }fib = fib.memoize() // 20 seconds to 0.001 seconds with caching enabledassert fib(40) == 165_580_141 // closure's isCase() implicitly being called for the followingdef odd = { it % 2 == 1 }assert [1,2,3].grep(odd) == [1, 3]switch(10) { case odd: assert false }if (2 in odd) assert falseWith closures, the programmer can control how references are resolved (to include the ‘this’ reference)While you cannot directly set ‘this’ to a different value, you can set a so-called delegate, which will be used when resolving free variables.
*Having the local closure scope, the delegate, and the owner raises the question of who is used for resolving references and, in case of conflicts, in which order. This again can be configured by setting the resolveStrategy to OWNER_ONLY, OWNER_FIRST (default), DELEGATE_ONLY, DELEGATE_FIRST, or SELF_ONLY.class Mother { def prop = 'prop' def method(){ 'method' } Closure birth (param) { def local = 'local' def closure = { [ this, prop, method(), local, param ] } // a closure return closure }}Mother julia = new Mother()def closure = julia.birth('param') // declare the closuredef context = closure.call() // execute the closureassert context[0] == julia // what 'this' refers to assert context[1, 2] == ['prop', 'method'] // bound variables of the closureassert context[3, 4] == ['local', 'param' ] // bound variables of the closureassert closure.thisObject == julia // read only assert closure.owner == julia // read only assert closure.delegate == julia // scope control (we can set it to a different object)assert closure.resolveStrategy == Closure.OWNER_FIRST // scope control// the with closure sets the delegate to the map def map = [:]map.with { // delegate is now map (so we don't have to call map every time) a = 1 // same as map.a = 1 b = 2 // same as map.b = 2}assert map == [a:1, b:2]there are two ways to return from a closureThe last expression has been evaluated and the result of the evaluation is returned (end return); using return keyword is optional.[1, 2, 3].collect{ it * 2 }[1, 2, 3].collect{ return it * 2 }The return keyword can be used to return from the closure prematurely// return ends the current evaluation of the closure (not the collect method) - the next iteration will take place[1, 2, 3].collect {if (it%2 == 0) return it * 2 return it}GroovyBeans and OO - groovy styleclassif they are declared with an AST @Immutable (e.g. @Immutable class SomeClass), they will not get a setter methodAST (abstract syntax tree) can sneak in new method implementations or add, delete, or modify any other code structure (compile-time meta-programming)class BookBean { String title BookBean() { println 'constructor' } void setTitle(def title) { println "title was set to $title" this.title = title }}def groovyBook = new BookBean() // prints constructorgroovyBook.title = 'test' // prints title was set to test (showing that setter method was called)fieldsThe default visibility for fields has a special meaning in Groovy. When no visibility modifier is attached to a field declaration, a property is generated for the respective name.A GroovyBean is a JavaBean defined in Groovy, but it does things for you:Generates the accessor methods for youProperties (i.e. instance fields) are bindableYou can use Groovy short hand to access properties
a. groovyBook.title = ‘some title’ // Groovy short hand setter (calls setter method)
b. println groovyBook.title // Groovy short hand (the field is not public)When no type and modifier are given, the def keyword must be used as a replacementTo extend (not override) a field access operator (i.e. subscript operator), provide the following methods:Object get (String name)void set (String name, Object value)overriding the get method means to override the dot-fieldname operator. Overriding the set method overrides the field-assignment operator.What about a statement of the form x.y.z=something? This is equivalent to getX().getY().setZ(something). // variable declaration examplesclass ClassWithTypedAndUntypedFieldsAndProperties { public fieldWithModifier String typedField def untypedField protected field1, field2, field3 private assignedField = new Date() static classField public static final String CONSTA = 'a', CONSTB = 'b' def someMethod(){ def localUntypedMethodVar = 1 int localTypedMethodVar = 1 def localVarWithoutAssignment, andAnotherOne }}// referencing fields with the subscript operatorclass Counter { public count = 0 }def counter = new Counter()counter.count = 1assert counter.count == 1def fieldName = 'count'counter[fieldName] = 2assert counter['count'] == 2assert counter.@count == 2// extending the general field-access mechanismclass PretendFieldCounter { public count = 0 int getCount() { println 'here'; return count } Object get (String name) { return 'pretend value' } void set (String name, Object value) { count++ }}def pretender = new PretendFieldCounter()println pretender.count // prints 'here', then 0; getCount() is implicitly calledprintln pretender.x // prints 'pretend value' -- the get() method above is implicitly calledassert pretender.isNoField == 'pretend value'assert pretender.count == 0pretender.isNoFieldEither = 'just to increase counter'assert pretender.count == 1methodsall methods are, by default, publicfor methods, return types are optional; if no modifiers or return are supplied, use def (return type is unrestricted - under covers, actual return type will be java.lang.Object (even if you intended a void return type).return keyword is optional for the last expression in a method or closure.Methods with explicit return type void don’t return a value; closures always return a value.The Java compiler fails on missing return statements when a return type is declared for the method. In Groovy, return statements are optional, therefore it’s impossible for the compiler to detect “accidentally” missing returns.declarations of exceptions in the method signature are optional, even for checked exceptionsgroovy allows special characters in method names if you quote them. It will even allow GStrings (e.g. “${var}”)// examples of ways to declare methodsclass ClassWithTypedAndUntypedMethods { // implicit public and args is implicit java.lang.Object (void is optional too) static void main(args) { def some = new ClassWithTypedAndUntypedMethods() some.publicVoidMethod() assert 'hi' == some.publicUntypedMethod() assert 'ho' == some.publicTypedMethod() combinedMethod() } void publicVoidMethod() { } def publicUntypedMethod() { return 'hi' } String publicTypedMethod() { return 'ho' } private static final void combinedMethod() { }}method argumentsmaps and lists can be used to constructor objects (if you don’t provide a constructor, it will implicitly receive map and list ones)Groovy supports defaults for argumentsWith Groovy’s method dispatch, you can override the invokeMethod(name, params[]) that every GroovyObject provides.// you can use a map to set the values (no constructors defined)class BookBean { String title String two // adding a constructor will break map constructor creation // method can include special characters when quoted and doesn't need an explicit return String "test it"() { "$title $two" }}def groovyBook = [title:'order', two:'not important'] as BookBeandef anotherBook = new BookBean([two:'order', title:'not important'])println groovyBook."test it"() // prints "order not important"println anotherBook."test it"() // prints "not important order"// you can use a list to set the values (constructor defined)class BookBean2 { String title String two // adding this constructor will break map constructor creation BookBean2(def title, def two) { println 'constructor' this.title = title this.two = two } String "test it"() { "$title $two" }}// you can use a map to set the valuesdef groovyBook = ['order', 'is important'] as BookBean2BookBean2 anotherBook = ['order', 'is important'] // coercion in assignmentprintln groovyBook."test it"() // prints "order is important"println anotherBook."test it"() // prints "order is important"// advanced parameter usesclass Summer { def sumWithDefaults(a, b, c=0) { return a + b + c } def sumWithList(List args) { return args.inject(0) { sum, i -> sum += i } } def sumWithOptionals(a, b, Object[] optionals) { return a + b + sumWithList(optionals.toList()) } def sumNamed(Map args){ ['a','b','c'].each { args.get(it, 0) } return args.a + args.b + args.c }}def summer = new Summer()assert 2 == summer.sumWithDefaults(1,1)assert 3 == summer.sumWithDefaults(1,1,1)assert 2 == summer.sumWithList([1,1])assert 3 == summer.sumWithList([1,1,1])assert 2 == summer.sumWithOptionals(1,1)assert 3 == summer.sumWithOptionals(1,1,1)assert 2 == summer.sumNamed(a:1, b:1)assert 3 == summer.sumNamed(a:1, b:1, c:1)assert 1 == summer.sumNamed(c:1)miscellaneousJava’s default package-wide visibility is supported via the @PackageScope annotation.Java 7 introduced a try-with-resources mechanism. At the time of writing, Groovy doesn’t support that syntax. try-with-resources isn’t needed in Groovy, where we have full closure support.Groovy provides the additional ?. operator for safe dereferencing; When the reference before that operator is a null reference, the evaluation of the current expression stops, and null is returned
